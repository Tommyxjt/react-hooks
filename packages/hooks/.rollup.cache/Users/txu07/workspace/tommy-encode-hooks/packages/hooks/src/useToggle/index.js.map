{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"AAAA,iBAAiB;AAEjB,OAAO,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AAgBjC;;;;;;;GAOG;AACH,SAAS,SAAS,CAAqB,YAAgB,EAAE,YAAgB;IACvE,QAAQ;IACR,IAAM,YAAY,GAAG,YAAY,aAAZ,YAAY,cAAZ,YAAY,GAAK,KAAW,CAAC;IAClD,IAAM,QAAQ,GAAG,YAAY,aAAZ,YAAY,cAAZ,YAAY,GAAK,CAAC,YAA6B,CAAC;IAE3D,IAAA,KAAoB,QAAQ,CAAQ,YAAY,CAAC,EAAhD,KAAK,QAAA,EAAE,QAAQ,QAAiC,CAAC;IAExD,IAAM,OAAO,GAAG;QACd,QAAQ,CAAC,YAAY,CAAC,CAAC;IACzB,CAAC,CAAC;IAEF,IAAM,QAAQ,GAAG;QACf,QAAQ,CAAC,QAAQ,CAAC,CAAC;IACrB,CAAC,CAAC;IAEF,IAAM,GAAG,GAAG,QAAQ,CAAC;IAErB,kCAAkC;IAClC,IAAM,MAAM,GAAG;QACb,QAAQ,CAAC,UAAC,OAAc,IAAK,OAAA,CAAC,OAAO,KAAK,YAAY,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY,CAAC,EAApD,CAAoD,CAAC,CAAC;IACrF,CAAC,CAAC;IAEF,IAAM,OAAO,GAAG;QACd,OAAO,SAAA;QACP,QAAQ,UAAA;QACR,GAAG,KAAA;QACH,MAAM,QAAA;KACP,CAAC;IAEF,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AAC1B,CAAC;AAED,eAAe,SAAS,CAAC","sourcesContent":["// useToggle 切换状态\n\nimport { useState } from 'react';\n\nexport interface Action<T> {\n  setLeft: () => void;\n  setRight: () => void;\n  set: (val: T) => void;\n  toggle: () => void;\n}\n\n// 重载声明1：无参数\nfunction useToggle<T = boolean>(): [T, Action<T>];\n// 重载声明2：一个参数\nfunction useToggle<T>(defaultValue: T): [T, Action<T>];\n// 重载声明3：两个参数\nfunction useToggle<T, U>(defaultValue: T, reverseValue: U): [T | U, Action<T | U>];\n\n/**\n * 场景：类似于开关\n// 1. useToggle() 不传参的相当于是 useBoolean，初始值为 false\n// 2. useToggle(a) 传参一个的情况下，参数必须是 boolean 类型\n// 3. useToggle(a, b) 传参两个的情况下，在 a 和 b 之间切换\n * @param {T} defaultValue\n * @param {T} reverseValue\n */\nfunction useToggle<T = boolean, U = T>(defaultValue?: T, reverseValue?: U): [T | U, Action<T | U>] {\n  // 处理默认值\n  const initialValue = defaultValue ?? (false as T);\n  const altValue = reverseValue ?? (!initialValue as unknown as U);\n\n  const [state, setState] = useState<T | U>(initialValue);\n\n  const setLeft = () => {\n    setState(initialValue);\n  };\n\n  const setRight = () => {\n    setState(altValue);\n  };\n\n  const set = setState;\n\n  // 这里直接使用state判断会有闭包问题，因此必须使用函数式更新\n  const toggle = () => {\n    setState((current: T | U) => (current === initialValue ? altValue : initialValue));\n  };\n\n  const actions = {\n    setLeft,\n    setRight,\n    set,\n    toggle,\n  };\n\n  return [state, actions];\n}\n\nexport default useToggle;\n"]}